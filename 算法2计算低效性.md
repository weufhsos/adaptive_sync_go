# 以服务器负载均衡为例解析分布式CRDT低效度计算算法（算法2）
本文以**双服务器（S1/S2）资源负载均衡**为具体场景，结合SDN控制器集群的本地/远端副本交互过程，解析算法2的执行逻辑，核心明确$\boldsymbol{S_{CtrU_k}}$的定义、**最优状态更新集合$S_{U_{cnst}}$**和**次优状态更新集合$S_{U_{incnst}}$**的形成过程，所有逻辑均贴合论文中CRDT（以PN计数器记录服务器资源利用率）和负载均衡的应用设定。

## 一、核心场景与关键概念前置
### 1. 负载均衡基础场景
假设SDN控制器集群包含**本地控制器CL**和**远端控制器CR**，均运行负载均衡应用（SDN-LB），负责将客户端请求分配至服务器S1、S2，以实现两台服务器的资源利用率（CPU/带宽）均衡；
用**CRDT的PN计数器**表征服务器资源状态：$Ctr_{S1}$对应S1的PN计数器、$Ctr_{S2}$对应S2的PN计数器，**计数器自增（INCREMENT）**代表给服务器分配请求（资源利用率上升），**计数器自减（DECREMENT）**代表释放服务器资源（资源利用率下降）；
客户端请求的分配决策，完全基于控制器本地PN计数器的当前值（即服务器资源状态）。

### 2. 关键符号$\boldsymbol{S_{CtrU_k}}$的定义（负载均衡场景下）
$S_{CtrU_k}$是算法2的核心输入参数，论文中定义为**状态$Ctr_k$的历史已记录更新集合**，在本负载均衡场景中，$S_{CtrU_k}$（$k$为S1/S2）表示**本地控制器CL上，针对目标服务器（S1/S2）PN计数器的**所有本地历史状态更新请求的集合**，且每个更新请求均携带**时间戳$U(T)$**和**触发该更新的客户端请求$U(R)$**两个核心属性。
**举例**：CL此前依次给S1分配3个请求、给S2分配2个请求，这5次分配操作对应的PN计数器自增更新，会以`<时间戳，客户端请求，操作类型（自增），增量>`的形式全部存入$S_{CtrU_{S1}}$和$S_{CtrU_{S2}}$，这是算法执行的**历史数据基础**。

### 3. 算法触发条件
算法2的执行由**本地控制器CL接收远端控制器CR的状态更新事件**触发：即远端CR给S1/S2分配/释放请求后，发起针对对应服务器PN计数器的远端状态更新$U_{Ctrk}^{remote}$（携带CR的更新时间戳$T_{remote}$、触发更新的客户端请求），CL捕获到该事件后，启动低效度计算流程，本质是**量化“本地因未及时感知远端更新，基于过时状态做负载均衡决策”带来的决策损失**。

## 二、算法2执行步骤（负载均衡场景具象化）
为让逻辑更清晰，设定**具体数值前提**：
- 目标服务器为S1，对应PN计数器$Ctr_{S1}$，记$S_{CtrU_{S1}}$为CL上S1的历史更新集合，包含4条本地更新记录，时间戳依次为$T_1、T_2、T_4、T_5$（均为CL的本地时间）；
- 远端CR发起针对S1的更新$U_{CtrS1}^{remote}$，操作类型为**自增（给S1分配1个请求）**，时间戳为$T_3$（$T_2<T_3<T_4$），记为$T_{remote}=T_3$；
- 负载均衡的**应用逻辑AppLogic()**：论文中定义为“基于服务器当前资源状态，将客户端请求分配至利用率更低的服务器”，是计算**最优决策**的核心依据。

以下按算法2的步骤，结合上述前提解析，**核心聚焦最优集合$S_{U_{cnst}}$和次优集合$S_{U_{incnst}}$的形成**。

### 步骤1：初始化空集
CL捕获到远端更新事件$update<CR, U_{CtrS1}^{remote}>$后，首先初始化：
$S_{U_{cnst}} := \emptyset$（最优状态更新集合，初始为空）；
$S_{U_{incnst}} := \emptyset$（次优状态更新集合，初始为空）。
$S_{U_{cnst}}$最终存储**理想情况下的最优状态更新序列**，$S_{U_{incnst}}$最终存储**实际发生的次优状态更新序列**，二者的对比是计算低效度的核心。

### 步骤2：筛选本地历史更新，构建最优集合的基础部分
遍历$S_{CtrU_{S1}}$中所有本地更新请求$U_{CtrS1}^{local}$，**将时间戳小于远端更新时间戳$T_3$的本地更新，加入$S_{U_{cnst}}$**：
```
for all U_{CtrS1}^{local} ∈ S_{CtrU_{S1}} do
    if U_{CtrS1}^{local}(T) < T_3 then
        S_{U_{cnst}} ← S_{U_{cnst}} ∪ U_{CtrS1}^{local}
```
**负载均衡场景执行结果**：$S_{CtrU_{S1}}$中时间戳$T_1、T_2$的本地更新被加入$S_{U_{cnst}}$，此时$S_{U_{cnst}} = \{T_1, T_2\}$。
**逻辑本质**：这部分本地更新发生在远端更新之前，是CL和CR都认可的“无冲突历史”，也是后续计算最优决策的**状态基础**。

### 步骤3：筛选次优请求，定位“决策偏差的源头”
再次遍历$S_{CtrU_{S1}}$中所有本地更新请求$U_{CtrS1}^{local}$，**将时间戳大于等于$T_3$的本地更新对应的客户端请求，加入次优请求集合$R_{U_{incnst}}$**：
```
for all U_{CtrS1}^{local} ∈ S_{CtrU_{S1}} do
    if U_{CtrS1}^{local}(T) ≥ T_3 then
        R_{U_{incnst}} ← R_{U_{incnst}} ∪ U_{CtrS1}^{local}(R)
```
**负载均衡场景执行结果**：$S_{CtrU_{S1}}$中时间戳$T_4、T_5$的本地更新，其对应的客户端请求$R_4、R_5$被加入$R_{U_{incnst}}$，此时$R_{U_{incnst}} = \{R_4, R_5\}$。
**逻辑本质**：$T_4、T_5$晚于远端更新的$T_3$，说明CL在**未感知到CR给S1分配请求的情况下**，基于**过时的S1资源状态**（未包含CR的$T_3$更新）对$R_4、R_5$做出了负载均衡分配决策，这些决策大概率是**次优/错误**的（比如S1实际已被CR分配了请求，利用率已上升，CL仍将$R_4、R_5$分配给S1，导致S1过载），这是后续构建最优集合的**修正对象**。

### 步骤4：修正次优决策，完成最优集合$S_{U_{cnst}}$的核心构建
遍历次优请求集合$R_{U_{incnst}}$中的所有客户端请求$RU$，通过**应用逻辑AppLogic()**，基于**步骤2的最优历史状态$S_{U_{cnst}}$**，重新计算针对这些请求的**最优本地更新$U_{Ctrk}^{localOpt}$**，并将其加入$S_{U_{cnst}}$：
```
for all RU ∈ R_{U_{incnst}} do
    U_{Ctrk}^{localOpt} := AppLogic(RU, S_{U_{cnst}})
    S_{U_{cnst}} ← S_{U_{cnst}} ∪ U_{Ctrk}^{localOpt}
```
**负载均衡场景执行结果**：
对$R_4、R_5$，AppLogic()基于$S_{U_{cnst}} = \{T_1, T_2\}$（未包含CR的$T_3$更新前的S1状态）**叠加CR的$T_3$更新**（S1利用率上升），重新做分配决策：原本CL将$R_4、R_5$分配给S1（次优），AppLogic()会将其分配给利用率更低的S2（最优），对应生成2个最优本地更新$U_{T4}^{opt}、U_{T5}^{opt}$，并加入$S_{U_{cnst}}$，此时$S_{U_{cnst}} = \{T_1, T_2, U_{T4}^{opt}, U_{T5}^{opt}\}$。
**逻辑本质**：这一步是**最优集合的核心修正过程**——针对那些因“本地未感知远端更新”做出的次优决策，基于**全局一致的状态**（整合了远端更新的历史）重新生成**理想的最优更新操作**，让$S_{U_{cnst}}$成为“无状态偏差的更新序列”。

### 步骤5：加入远端更新，最终确定**最优状态更新集合$S_{U_{cnst}}$**
将远端控制器的更新$U_{CtrS1}^{remote}$（$T_3$）加入$S_{U_{cnst}}$，完成最优集合的构建：
```
S_{U_{cnst}} ← S_{U_{cnst}} ∪ U_{Ctrk}^{remote}
```
**负载均衡场景执行结果**：$S_{U_{cnst}} = \{T_1, T_2, U_{T4}^{opt}, U_{T5}^{opt}, T_3\}$（时间戳按实际时序排序为$T_1、T_2、T_3、U_{T4}^{opt}、U_{T5}^{opt}$）。
**最优集合的本质**：$S_{U_{cnst}}$是**整合了本地无冲突历史+远端更新+次优请求修正后**的**全局一致、决策最优的状态更新序列**，代表“如果CL能实时感知远端更新，负载均衡应用应该做出的理想状态更新操作”，是后续评价决策质量的**基准**。

### 步骤6：合并历史与远端更新，最终确定**次优状态更新集合$S_{U_{incnst}}$**
将本地控制器的历史更新集合$S_{CtrU_k}$与远端更新$U_{Ctrk}^{remote}$直接合并，得到次优集合：
```
S_{U_{incnst}} ← S_{CtrU_k} ∪ U_{Ctrk}^{remote}
```
**负载均衡场景执行结果**：$S_{U_{incnst}} = \{T_1, T_2, T_4, T_5, T_3\}$，其中$T_4、T_5$是CL基于**过时状态**做出的**实际次优更新操作**。
**次优集合的本质**：$S_{U_{incnst}}$是**实际发生的、未做任何修正的状态更新序列**，包含了本地因“状态不同步”产生的次优决策，是负载均衡应用**实际的状态更新记录**。

### 步骤7：计算低效度并上报
基于最终的最优、次优集合，通过**CompInefficiency()**函数计算低效度指标$\phi$（论文中用**标准差**量化负载均衡的资源分配失衡度），并上报至OCA模块用于一致性级别（CL）的动态调整：
```
φ = CompInefficiency (S_{U_{incnst}}, S_{U_{cnst}})
reportIneff(φ)
```
