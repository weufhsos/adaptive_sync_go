### 核心场景设定
*   **目标**：将客户端的服务请求（带有带宽/CPU等资源需求）分配给最合适的**服务节点（Server Node）**，以实现资源利用率的平衡。
*   **状态存储**：每个控制器副本都在本地内存中维护所有服务节点的当前资源利用率。这个状态是通过 **CRDT（PN-Counter）** 数据结构来存储的（支持并发增减）。

---

### 详细处理流程

#### 1. 请求到达 (Request Arrival)
*   客户端发起一个服务嵌入请求（Service Embedding Request）。
*   该请求被发送到分布式控制器集群中的**某一个**控制器副本（我们称之为 **本地副本 $C_{local}$**）。
*   请求包含所需的资源成本（Cost，例如需要 10% 的 CPU）。

#### 2. 本地决策 (Local Decision Making)
*   **读取状态**：$C_{local}$ 查看自己**本地内存**中记录的各个服务节点的资源利用率。
    *   *注意*：在最终一致性（EC）或自适应一致性（AC）模式下，这个“本地视图”可能不是最新的（即其他控制器处理的分配可能还没同步过来）。
*   **执行算法**：运行负载均衡算法（Greedy算法），在满足资源约束的前提下，选择一个能使整体资源利用率最平衡的服务器。
*   **做出决定**：假设决定分配给 **Server A**。

#### 3. 状态更新 (State Update via CRDT)
*   $C_{local}$ 立即在本地更新 Server A 的状态（资源占用增加）。
*   由于使用了 CRDT PN-Counter（正负计数器），这个操作本质上是一个 `increment` 操作，不需要加全局锁。

#### 4. 同步与分发 (Synchronization & Distribution)
    1.  **入队**：将这次更新放入一个“状态更新分发队列”。
    2.  **检查阈值**：检查当前应用的一致性等级（Consistency Level, CL）。CL 决定了两个参数：**最大队列长度 ($QS$)** 和 **最大等待时间 ($T_O$)**。
    3.  **决策**：
        *   如果队列未满且时间未到：**暂存**，不发送（为了减少开销）。
        *   如果队列已满或超时：**打包**队列中的更新，**广播**给集群中的其他副本（$C_{remote}$）。

#### 5. 远程接收与合并 (Remote Merge)
*   其他控制器副本（$C_{remote}$）收到 $C_{local}$ 发来的更新包。
*   利用 CRDT 的 `merge` 函数，将更新合并到自己的本地状态中，从而感知到 Server A 的负载增加了。

#### 6. 性能检查与“后悔”计算 (Performance Inspection - PI)
*   **触发时机**：当 $C_{local}$ 收到来自其他副本的延迟到达的更新时（意味着 $C_{local}$ 之前可能基于旧数据做了决策）。
*   **回溯分析**：
    1.  **重构历史**：算法会重排操作日志，还原出“如果当时数据是实时的，最佳决策（Optimal）是什么”。
    2.  **对比**：对比“当时的实际决策（Observed/Suboptimal）”和“最佳决策”。
    3.  **计算低效度 (Inefficiency Metric, $\phi$)**：计算两者的比率。如果实际决策导致资源很不平衡，说明数据太旧了，$\phi$ 值会很高。

#### 7. 在线自适应调整 (Online Consistency Adaptation - OCA)
*   **闭环控制**：根据上一步计算出的低效度 $\phi$（Inefficiency），输入到自适应函数（如阈值法或 PID 控制器）。
*   **调整参数**：
    *   如果 $\phi$ 高（决策质量差）：**提高一致性等级**（降低队列长度 $QS$，减少等待时间 $T_O$），强迫状态同步得更频繁。
    *   如果 $\phi$ 低（决策质量好）：**降低一致性等级**（增加 $QS$ 和 $T_O$），允许更多暂存，以减少网络开销。

---

### 总结
整个流程概括为：
**接请求 -> 查本地旧数据 -> 做决策 -> 改本地数据 -> (根据CL判断是否立即同步) -> 收到别人迟来的数据 -> 后悔并计算差值 -> 调整下一次的同步策略。**
